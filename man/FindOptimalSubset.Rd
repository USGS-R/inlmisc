% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FindOptimalSubset.R
\name{FindOptimalSubset}
\alias{FindOptimalSubset}
\title{Genetic Algorithm for Subset Selection}
\usage{
FindOptimalSubset(n, k, Fitness, ..., popSize = 50L, migrationRate = 0.1,
  migrationInterval = 10L, pcrossover = 0.8, pmutation = 0.1,
  elitism = 0L, maxiter = 100L, run = maxiter, suggestions = NULL,
  parallel = FALSE, seed = NULL)
}
\arguments{
\item{n}{'integer'.
Maximum permissible index, that is, the size of the integer sequence.
The function chooses a subset of integers from \code{1:n}.}

\item{k}{'integer'.
Number of indices to choose, that is, the size of the subset.}

\item{Fitness}{'function'.
Fitness function (also known as an objective function), any allowable \R function which
takes as its first and second argument
the binary \code{string} representing a potential solution and
the maximum permissible index (\code{n}), respectively.
The fitness function returns a single numerical value describing its \dQuote{fitness} score.
Note that the \code{\link{DecodeChromosome}} function is provided to decode the binary string,
see \sQuote{Examples} section.}

\item{...}{Additional arguments to be passed to the fitness function.}

\item{popSize}{'integer'.
Population size}

\item{migrationRate}{'numeric'.
Proportion of individuals that should migrate between islands.}

\item{migrationInterval}{'integer'.
Number of iterations at which exchange of individuals takes place.
This interval between migrations is called an \emph{epoch}.}

\item{pcrossover}{'numeric'.
Probability of crossover between pairs of chromosomes.}

\item{pmutation}{'numeric'.
Probability of mutation in a parent chromosome.}

\item{elitism}{'integer'.
Number of chromosomes to survive into the next generation.}

\item{maxiter}{'integer'.
Maximum number of iterations to run before the GA search is halted.}

\item{run}{'integer'.
Number of consecutive generations without any improvement in the
\dQuote{best} fitness value before the GA is stopped.}

\item{suggestions}{'matrix'.
Initial population}

\item{parallel}{'logical' or 'integer'.
Whether to use parallel computing.
This argument can also be used to specify the number of cores (and islands) to employ;
by default, this is taken from \code{\link[parallel]{detectCores}}.}

\item{seed}{'integer'.
Random number generator state, used to replicate the results.}
}
\value{
Returns a 'list' with components:
  \describe{
    \item{\code{call}}{original call which can be used for later re-use.}
    \item{\code{solution}}{a 'matrix' representation of the best solution found.
      Each row represents a unique solution giving the best fitness at the final iteration.
      More than one row indicates a non-unique solution.
      The number of columns is equal to the subset size (\code{k}).}
    \item{\code{ga_output}}{output from the GA,
      see \code{\link[=gaisl-class]{gaisl-class}} for format description.}
    \item{\code{ga_time}}{time required to run the GA,
      see \code{\link{system.time}} for details.}
  }
}
\description{
This function identifies an optimal subset of a fixed size from a finite sequence (\code{1:n}).
A distributed multiple-population genetic algorithm (GA) is used to do subset selection
based on the maximization of a user-supplied fitness function.
}
\details{
The fitness function (see \code{Fitness} argument) is
  solved using the \code{\link[GA]{gaisl}} function in the \pkg{GA} package (Scrucca, 2013; Scrucca, 2016).
  The function implements the islands GAs approach.
  Independent GAs are configured to use integer chromosomes,
  where indices are represented as binary strings using \href{https://en.wikipedia.org/wiki/Gray_code}{Gray} encoding;
  linear-rank selection; uniform crossover; and uniform mutation.
}
\examples{
# Choose the 4 smallest numbers from a list of 100 values
# genearated from a standard uniform distribution.
k <- 4
n <- 100
numbers <- sort(runif(n))
Fitness <- function(string, n, numbers) {
  idxs <- DecodeChromosome(string, n)
  score <- -sum(numbers[idxs])
  return(score)
}
\dontrun{
out <- FindOptimalSubset(n, k, Fitness, numbers, elitism = 1, seed = 321)
print(out[["solution"]])
plot(out[["ga_output"]])
summary(out[["ga_output"]])
print(out[["ga_output"]]@fitnessValue)
}

}
\references{
Scrucca, Luca, 2013, GA: A Package for Genetic Algorithms in R:
  Journal of Statistical Software, v. 53, no. 4, p. 1-37.

  Scrucca, Luca, 2017, On some extensions to GA package: hybrid optimisation,
  parallelisation and islands evolution: The R Journal, v. 9, no. 1, 187-206.
}
\author{
J.C. Fisher, U.S. Geological Survey, Idaho Water Science Center
}
\keyword{optimize}
